---
title: Improving error reporting
document: P3609R0
date: today
author:
    - name: Lucian Radu Teodorescu (Garmin)
      email: <lucteo@lucteo.ro>
    - name: Brad Larson (Garmin)
audience:
    - EWG, LEWG
---

<style>
@media screen {
    #TOC {
        position: fixed;
        width: min(25%, 30em);
        height: 100%;
        left: 0;
        top: 0;
        overflow-y: scroll;
        padding-left: 1em;
        padding-right: 1em;
        text-align: left;
        a {
            font-size: 100%;
        }
    }
    body {
        padding-left: min(26%, 32em);
    }
}
</style>

# Abstract # {- .unlisted}

Error reporting is often considered a weak point of C++; this is especially true in code that is heavily templated.
There are times when the actual source of the error is not properly captured in the error messages.
There are other cases where the error messages are so long that, even if the source of the error is properly captured, it gets hidden in the noise.
Also, different compilers approach error reporting differently; library authors who try to improve error reporting on one compiler often make the errors hard to interpret on other compilers.

This paper proposes a mechanism by which library authors can control error reporting for some misuses of their library.

<!-- # Change history # {- .unlisted}

TODO -->

# Motivation

C++ is notoriously bad at error reporting.
This is especially true if the error is related to template instantiations.
Concepts help, but oftentimes errors produced are long and confusing.
Other techniques, like using `static_assert`s in the body of the functions help, but they too have limitations.

Here is an example of erroneous C++ code:
```
std::tuple<int, double> t;
auto x = std::get<float>(t);
```

On gcc 15.1, this produces an error log similar to:
```
In file included from <source>:1:
/opt/compiler-explorer/gcc-15.1.0/include/c++/15.1.0/tuple: In instantiation of 'constexpr _Tp& std::get(tuple<_Elements ...>&) [with _Tp = float; _Types = {int, double}]':
<source>:5:29:   required from here
    5 |     auto x = std::get<float>(t);
      |              ~~~~~~~~~~~~~~~^~~
/opt/compiler-explorer/gcc-15.1.0/include/c++/15.1.0/tuple:2485:27: error: static assertion failed: the type T in std::get<T> must occur exactly once in the tuple
 2485 |       static_assert(__idx < sizeof...(_Types),
      |                     ~~~~~~^~~~~~~~~~~~~~~~~~~
/opt/compiler-explorer/gcc-15.1.0/include/c++/15.1.0/tuple:2485:27: note: the comparison reduces to '(2 < 2)'
/opt/compiler-explorer/gcc-15.1.0/include/c++/15.1.0/tuple:2487:38: error: use of deleted function 'std::__enable_if_t<(__i >= sizeof... (_Types))> std::__get_helper(const tuple<_Elements ...>&) [with long unsigned int __i = 2; _Types = {int, double}; __enable_if_t<(__i >= sizeof... (_Types))> = void]'
 2487 |       return std::__get_helper<__idx>(__t);
      |              ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~
/opt/compiler-explorer/gcc-15.1.0/include/c++/15.1.0/tuple:2439:5: note: declared here
 2439 |     __get_helper(const tuple<_Types...>&) = delete;
      |     ^~~~~~~~~~~~
/opt/compiler-explorer/gcc-15.1.0/include/c++/15.1.0/tuple:2487:38: note: use '-fdiagnostics-all-candidates' to display considered candidates
 2487 |       return std::__get_helper<__idx>(__t);
      |              ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~
Compiler returned: 1
```

On clang 20.1.0 we have:
```
In file included from <source>:1:
/opt/compiler-explorer/gcc-14.2.0/lib/gcc/x86_64-linux-gnu/14.2.0/../../../../include/c++/14.2.0/tuple:2484:21: error: static assertion failed due to requirement '__idx < sizeof...(_Types)': the type T in std::get<T> must occur exactly once in the tuple
 2484 |       static_assert(__idx < sizeof...(_Types),
      |                     ^~~~~~~~~~~~~~~~~~~~~~~~~
<source>:5:19: note: in instantiation of function template specialization 'std::get<float, int, double>' requested here
    5 |     auto x = std::get<float>(t);
      |                   ^
/opt/compiler-explorer/gcc-14.2.0/lib/gcc/x86_64-linux-gnu/14.2.0/../../../../include/c++/14.2.0/tuple:2484:27: note: expression evaluates to '2 < 2'
 2484 |       static_assert(__idx < sizeof...(_Types),
      |                     ~~~~~~^~~~~~~~~~~~~~~~~~~
/opt/compiler-explorer/gcc-14.2.0/lib/gcc/x86_64-linux-gnu/14.2.0/../../../../include/c++/14.2.0/tuple:2486:14: error: call to deleted function '__get_helper'
 2486 |       return std::__get_helper<__idx>(__t);
      |              ^~~~~~~~~~~~~~~~~~~~~~~~
/opt/compiler-explorer/gcc-14.2.0/lib/gcc/x86_64-linux-gnu/14.2.0/../../../../include/c++/14.2.0/tuple:2438:5: note: candidate function [with __i = 2, _Types = <int, double>] has been explicitly deleted
 2438 |     __get_helper(const tuple<_Types...>&) = delete;
      |     ^
/opt/compiler-explorer/gcc-14.2.0/lib/gcc/x86_64-linux-gnu/14.2.0/../../../../include/c++/14.2.0/tuple:2427:5: note: candidate template ignored: could not match '_Tuple_impl' against 'tuple'
 2427 |     __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
      |     ^
/opt/compiler-explorer/gcc-14.2.0/lib/gcc/x86_64-linux-gnu/14.2.0/../../../../include/c++/14.2.0/tuple:2432:5: note: candidate template ignored: could not match '_Tuple_impl' against 'tuple'
 2432 |     __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
      |     ^
/opt/compiler-explorer/gcc-14.2.0/lib/gcc/x86_64-linux-gnu/14.2.0/../../../../include/c++/14.2.0/tuple:2486:14: error: non-const lvalue reference to type 'float' cannot bind to a temporary of type '__enable_if_t<(2UL >= sizeof...(_Types))>' (aka 'void')
 2486 |       return std::__get_helper<__idx>(__t);
      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
3 errors generated.
Compiler returned: 1
```

(The output is copied verbatim from Compiler Explorer, using indicated compilers, with no extra compiler flags.)

There are several problems with this diagnostic that will make it hard for the users to understand where the source of the problem lies:

* the actual error doesn't properly say what is wrong
  * the code points to `__idx < sizeof...(_Types)`, but that has nothing familiar to the user
  * the error message says `the type T in std::get<T> must occur exactly once in the tuple`, but that is not very specific.
* the actual error source is inside of the standard library, not in the user code
  * in both cases, there is a note pointing to the user code, buried inside of multiple lines of library error/nodes
* we see secondary errors in the output
* the error message is too long, contains too much noise, making it harder to focus on the real issue

What we really want instead is something like:
```
<source>:5:19: error: there is no element of type 'float' in tuple with types <int, double>
    5 |     auto x = std::get<float>(t);
      |                   ^
```

That is it; no extra line pointing inside the source code of standard library.

If, on the other hand, we slightly change the problem to the following code:
```
std::tuple<int, double, float, float> t;
auto x = std::get<float>(t);
```
, the exact call to `std::get<float>` should produce an error message like:
```
<source>:5:19: error: the element of type 'float' appears multiple times in tuple with types <int, double, float, float>
    5 |     auto x = std::get<float>(t);
      |                   ^
```

To achieve this error reporting, we envision a facility that allows library authors to control error reporting on template/concept instantiations, with the following characteristics:

* report meaningful errors that explain why the library is misused
* allow error reporting to point to the user code (and not library code)
* allows the user to dynamically generate diagnostic messages based on the instantiation parameters
* does not add (significant) burden on the compiler if compilation is successful

# Examples

## `stdexec` sender mismatch

For the given snipped:
```
ex::sender auto s = ex::just() | ex::then([](int x) { return x; });
```

we get the following errors on clang 20.1.0:
```
In file included from <source>:1:
In file included from /opt/compiler-explorer/libs/stdexec/trunk/include/stdexec/execution.hpp:33:
In file included from /opt/compiler-explorer/libs/stdexec/trunk/include/stdexec/__detail/__execute.hpp:25:
/opt/compiler-explorer/libs/stdexec/trunk/include/stdexec/__detail/__then.hpp:48:62: error: deduced type 'stdexec::(anonymous namespace)::__sexpr<stdexec::(lambda at /opt/compiler-explorer/libs/stdexec/trunk/include/stdexec/__detail/__basic_sender.hpp:45:7){}>' does not satisfy '__well_formed_sender'
   48 |       auto operator()(_Sender&& __sndr, _Fun __fun) const -> __well_formed_sender auto {
      |                                                              ^~~~~~~~~~~~~~~~~~~~~~~~~
/opt/compiler-explorer/libs/stdexec/trunk/include/stdexec/__detail/__meta.hpp:901:36: note: in instantiation of function template specialization 'stdexec::__then::then_t::operator()<stdexec::(anonymous namespace)::__sexpr<stdexec::(lambda at /opt/compiler-explorer/libs/stdexec/trunk/include/stdexec/__detail/__basic_sender.hpp:45:7){}>, (lambda at <source>:6:47)>' requested here
  901 |   using __call_result_t = decltype(__declval<_Fun>()(__declval<_As>()...));
      |                                    ^
/opt/compiler-explorer/libs/stdexec/trunk/include/stdexec/__detail/__sender_adaptor_closure.hpp:123:14: note: in instantiation of template type alias '__call_result_t' requested here
  123 |           -> __call_result_t<_Fun, _Sender, _As...> {
      |              ^
/opt/compiler-explorer/libs/stdexec/trunk/include/stdexec/__detail/__meta.hpp:901:36: note: while substituting deduced template arguments into function template 'operator()' [with _Sender = stdexec::(anonymous namespace)::__sexpr<stdexec::(lambda at /opt/compiler-explorer/libs/stdexec/trunk/include/stdexec/__detail/__basic_sender.hpp:45:7){}>]
  901 |   using __call_result_t = decltype(__declval<_Fun>()(__declval<_As>()...));
      |                                    ^
/opt/compiler-explorer/libs/stdexec/trunk/include/stdexec/__detail/__sender_adaptor_closure.hpp:74:10: note: in instantiation of template type alias '__call_result_t' requested here
   74 |       -> __call_result_t<_Closure, _Sender> {
      |          ^
<source>:6:36: note: while substituting deduced template arguments into function template 'operator|' [with _Sender = __sexpr_t<just_t, __tuple<nullptr>>, _Closure = __binder_back<then_t, (lambda at <source>:6:47)>]
    6 |     ex::sender auto s = ex::just() | ex::then([](int x) { return x; });
      |                                    ^
/opt/compiler-explorer/libs/stdexec/trunk/include/stdexec/__detail/__senders.hpp:345:34: note: because '__minvoke<__with_default_q<__completion_signatures_of_t, dependent_completions>, __sexpr<(lambda at /opt/compiler-explorer/libs/stdexec/trunk/include/stdexec/__detail/__basic_sender.hpp:45:7){}>>' (aka '_ERROR_<stdexec::_NOT_CALLABLE_<__mstring<38UL>{"In stdexec::then(Sender, Function)[...]"}, __mstring<68UL>{"The specified function is not call[...]"}>, stdexec::_WITH_FUNCTION_<(lambda at <source>:6:47)>, stdexec::_WITH_ARGUMENTS_<>>') does not satisfy '__well_formed_completions'
  345 |   concept __well_formed_sender = __detail::__well_formed_completions<
      |                                  ^
/opt/compiler-explorer/libs/stdexec/trunk/include/stdexec/__detail/__senders.hpp:51:41: note: because '__well_formed_completions_v<stdexec::_ERROR_<stdexec::_NOT_CALLABLE_<__mstring<38UL>{"In stdexec::then(Sender, Function)..."}>, stdexec::_WITH_FUNCTION_<(lambda at <source>:6:47)>, stdexec::_WITH_ARGUMENTS_<> > >' evaluated to false
   51 |     concept __well_formed_completions = __well_formed_completions_v<_Completions>;
      |                                         ^
<source>:6:36: error: invalid operands to binary expression ('__sexpr_t<just_t, __tuple<nullptr>>' (aka '__sexpr<stdexec::__descriptor_fn_v<stdexec::__detail::__desc<just_t, __tuple<nullptr>>>>') and '__binder_back<then_t, (lambda at <source>:6:47)>')
    6 |     ex::sender auto s = ex::just() | ex::then([](int x) { return x; });
      |                         ~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
/opt/compiler-explorer/libs/stdexec/trunk/include/stdexec/__detail/__sender_adaptor_closure.hpp:73:45: note: candidate template ignored: substitution failure [with _Sender = __sexpr_t<just_t, __tuple<nullptr>>, _Closure = __binder_back<then_t, (lambda at <source>:6:47)>]: no matching function for call to object of type 'stdexec::__closure::__binder_back<stdexec::__then::then_t, (lambda at <source>:6:47)>'
   73 |     STDEXEC_ATTRIBUTE((always_inline)) auto operator|(_Sender&& __sndr, _Closure&& __clsur) //
      |                                             ^
/opt/compiler-explorer/libs/stdexec/trunk/include/stdexec/__detail/__sender_adaptor_closure.hpp:79:45: note: candidate template ignored: constraints not satisfied [with _T0 = __sexpr_t<just_t, __tuple<nullptr>>, _T1 = __binder_back<then_t, (lambda at <source>:6:47)>]
   79 |     STDEXEC_ATTRIBUTE((always_inline)) auto operator|(_T0&& __t0, _T1&& __t1) //
      |                                             ^
/opt/compiler-explorer/libs/stdexec/trunk/include/stdexec/__detail/__sender_adaptor_closure.hpp:78:15: note: because 'stdexec::(anonymous namespace)::__sexpr<stdexec::(lambda at /opt/compiler-explorer/libs/stdexec/trunk/include/stdexec/__detail/__basic_sender.hpp:45:7){}>' does not satisfy '__sender_adaptor_closure'
   78 |     template <__sender_adaptor_closure _T0, __sender_adaptor_closure _T1>
      |               ^
/opt/compiler-explorer/libs/stdexec/trunk/include/stdexec/__detail/__sender_adaptor_closure.hpp:36:5: note: because 'derived_from<__decay_t<__sexpr<(lambda at /opt/compiler-explorer/libs/stdexec/trunk/include/stdexec/__detail/__basic_sender.hpp:45:7){}> >, sender_adaptor_closure<__decay_t<__sexpr<(lambda at /opt/compiler-explorer/libs/stdexec/trunk/include/stdexec/__detail/__basic_sender.hpp:45:7){}> > > >' evaluated to false
   36 |     derived_from<__decay_t<_Tp>, sender_adaptor_closure<__decay_t<_Tp>>>
      |     ^
/opt/compiler-explorer/gcc-14.2.0/lib/gcc/x86_64-linux-gnu/14.2.0/../../../../include/c++/14.2.0/concepts:74:28: note: because '__is_base_of(stdexec::__closure::sender_adaptor_closure<stdexec::(anonymous namespace)::__sexpr<stdexec::(lambda at /opt/compiler-explorer/libs/stdexec/trunk/include/stdexec/__detail/__basic_sender.hpp:45:7){}> >, stdexec::(anonymous namespace)::__sexpr<stdexec::(lambda at /opt/compiler-explorer/libs/stdexec/trunk/include/stdexec/__detail/__basic_sender.hpp:45:7){}>)' evaluated to false
   74 |     concept derived_from = __is_base_of(_Base, _Derived)
      |                            ^
/opt/compiler-explorer/libs/stdexec/trunk/include/stdexec/execution.hpp:78:6: note: candidate template ignored: constraints not satisfied [with _Ignore = __sexpr_t<just_t, __tuple<nullptr>>, _Sender = __binder_back<then_t, (lambda at <source>:6:47)>]
   78 | auto operator|(_Ignore&&, _Sender&&) noexcept;
      |      ^
/opt/compiler-explorer/libs/stdexec/trunk/include/stdexec/execution.hpp:76:36: note: because 'stdexec::__closure::__binder_back<stdexec::__then::then_t, (lambda at <source>:6:47)>' does not satisfy 'sender'
   76 | template <stdexec::sender _Ignore, stdexec::sender _Sender>
      |                                    ^
/opt/compiler-explorer/libs/stdexec/trunk/include/stdexec/__detail/__senders_core.hpp:49:5: note: because 'enable_sender<__decay_t<__binder_back<then_t, (lambda at <source>:6:47)> > >' evaluated to false
   49 |     enable_sender<__decay_t<_Sender>>                     //
      |     ^
2 errors generated.
```

Notes:

* `stdexec` does some heavy lifting to produce some errors that contain some meaningful hints to the user:
  * <code>_ERROR_<stdexec::_NOT_CALLABLE_<__mstring<38UL>{"In stdexec::then(Sender, Function)[...]"}, __mstring<68UL>{"The specified function is not call[...]"}>, stdexec::_WITH_FUNCTION_<(lambda at <source>:6:47)>, stdexec::_WITH_ARGUMENTS_<>>') does not satisfy '__well_formed_completions</code>
  * <code>because '__well_formed_completions_v<stdexec::_ERROR_<stdexec::_NOT_CALLABLE_<__mstring<38UL>{"In stdexec::then(Sender, Function)..."}>, stdexec::_WITH_FUNCTION_<(lambda at <source>:6:47)>, stdexec::_WITH_ARGUMENTS_<> > >' evaluated to false</code>
* while these may provide good hints, they still don't properly tell the user what is wrong
* please note that the messages are cut
* these error messages don't work well on all compilers (e.g., MSVC)

A better error message would be:
```
<source>:6:36: error: function passed to 'then' cannot be called with values produced by the previous sender: ()
    6 |     ex::sender auto s = ex::just() | ex::then([](int x) { return x; });
      |                         ~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<source>:6:36: note: use '-fexpand-errors=2' to view more information
    6 |     ex::sender auto s = ex::just() | ex::then([](int x) { return x; });
      |                         ~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
```

Here we envision a new compiler flag that controls how much of the error is expanded.
Passing `-fexpand-errors=2` here would produce the following output:
```
<source>:6:36: error: function passed to 'then' cannot be called with values produced by the previous sender: ()
    6 |     ex::sender auto s = ex::just() | ex::then([](int x) { return x; });
      |                         ~~~~~~~~~~ ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
<source>:6:25: note: previous sender produces the following completion signatures: 'set_value()'
    6 |     ex::sender auto s = ex::just() | ex::then([](int x) { return x; });
      |                         ^ ~~~~~~~~
```

The examples involving senders are particularly interesting as, sometimes we detect an error only after we've built the entire flow of senders.
In other words, the same expression might be valid or not depending on what senders follow after it.

# Design overview

For the `tuple` example given in the motivation, we envision the author of the library would annotate the `get` function template in the following way:

```cpp
template <typename T, typename... Types>
constexpr T& get(tuple<Types...>& t) noexcept
  requires(...)
  catch(report_instantiation_errors<T, Types...>()) // NEW
{...}
```

We add the `catch(...)` syntax to introduce an _instantiation error handler_.
This handler is called whenever the function fails to instantiate.
In this case, if we fail to instantiate `get<float>(t)`, the `report_instantiation_errors<T, Types...>()` function will be called at compile-time.
This function may look something like the following:
```cpp
template <typename T, typename... Types>
consteval std::diagnostics::diagnostic report_instantiation_errors() {
    using namespace std::diagnostics;
    if (type_count<T, Types...>() > 1)
        return error("the element of type '", type<T>(), "' appears multiple times in tuple with types ", types<Types...>);
    else
        return error("there is no element of type '", type<T>(), "' in tuple with types ", types<Types...>);
}
```

Here, the `std::diagnostic` namespace is provided as part of this feature, and `error`, `type` and `types` are function declarations in this namespace.

The main idea is that this function will be evaluated if we cannot instantiate the `get` function.
The result of calling this function will be reported by the compiler as a diagnostic.
In this case the diagnostic isa simple error; but, we can easily imagine cases in which we produce an error plus a series of additional notes.

## Rules around instantiation error handler

For an instantiation error handler expression we have the following rules:

* can be applied to templates (class, function, variables) or concepts
* will only be evaluated if an instantiation error occurs on the corresponding declaration
* can use the same expressions that can be used in a `requires` clause
* can use the source-code locations of the template arguments (TODO)
* can use the source-code locations of the arguments, in case of functions (TODO)

## Library support

TODO

* representing diagnostics
* representing errors and notes
* representing source code locations
* obtaining source code locations from function arguments and template arguments
* printing types, type lists
* obtaining the value passed to the `-fexpand-errors` compiler flag
* try instantiating a template and get the corresponding error (custom messages only, or final messages)

# Design discussions

## Static asserts are not enough

TODO

TODO

# Implementation

TODO

# Specification

TODO

<!--
References:
- https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1267r0.pdf
- https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2429r0.pdf
- https://discourse.llvm.org/t/rfc-improving-clang-s-diagnostics/62584/1

-->