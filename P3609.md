---
title: Improving error reporting
document: P3609R0
date: today
author:
    - name: Lucian Radu Teodorescu (Garmin)
      email: <lucteo@lucteo.ro>
    - name: Brad Larson (Garmin)
audience:
    - EWG, LEWG
---

<style>
@media screen {
    #TOC {
        position: fixed;
        width: min(25%, 30em);
        height: 100%;
        left: 0;
        top: 0;
        overflow-y: scroll;
        padding-left: 1em;
        padding-right: 1em;
        text-align: left;
        a {
            font-size: 100%;
        }
    }
    body {
        padding-left: min(26%, 32em);
    }
}
</style>

# Abstract # {- .unlisted}

Error reporting is often considered a weak point of C++; this is especially true in code that is heavily templated.
There are times when the actual source of the error is not properly captured in the error messages.
There are other cases where the error messages are so long that, even if the source of the error is properly captured, it gets hidden in the noise.
Also, different compilers approach error reporting differently; library authors who try to improve error reporting on one compiler often make the errors hard to interpret on other compilers.

This paper proposes a mechanism by which library authors can control error reporting for some misuses of their library.

<!-- # Change history # {- .unlisted}

TODO -->

# Motivation # {#motivation}

C++ is notoriously bad at error reporting.
This is especially true if the error is related to template instantiations.
Concepts help, but oftentimes errors produced are long and confusing.
Other techniques, like using `static_assert`s in the body of the functions help, but they too have limitations.

Here is an example of erroneous C++ code:
```
std::tuple<int, double> t;
auto x = std::get<float>(t);
```

On gcc 15.1, this produces an error log similar to:
```
In file included from <source>:1:
/opt/compiler-explorer/gcc-15.1.0/include/c++/15.1.0/tuple: In instantiation of 'constexpr _Tp& std::get(tuple<_Elements ...>&) [with _Tp = float; _Types = {int, double}]':
<source>:5:29:   required from here
    5 |     auto x = std::get<float>(t);
      |              ~~~~~~~~~~~~~~~^~~
/opt/compiler-explorer/gcc-15.1.0/include/c++/15.1.0/tuple:2485:27: error: static assertion failed: the type T in std::get<T> must occur exactly once in the tuple
 2485 |       static_assert(__idx < sizeof...(_Types),
      |                     ~~~~~~^~~~~~~~~~~~~~~~~~~
/opt/compiler-explorer/gcc-15.1.0/include/c++/15.1.0/tuple:2485:27: note: the comparison reduces to '(2 < 2)'
/opt/compiler-explorer/gcc-15.1.0/include/c++/15.1.0/tuple:2487:38: error: use of deleted function 'std::__enable_if_t<(__i >= sizeof... (_Types))> std::__get_helper(const tuple<_Elements ...>&) [with long unsigned int __i = 2; _Types = {int, double}; __enable_if_t<(__i >= sizeof... (_Types))> = void]'
 2487 |       return std::__get_helper<__idx>(__t);
      |              ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~
/opt/compiler-explorer/gcc-15.1.0/include/c++/15.1.0/tuple:2439:5: note: declared here
 2439 |     __get_helper(const tuple<_Types...>&) = delete;
      |     ^~~~~~~~~~~~
/opt/compiler-explorer/gcc-15.1.0/include/c++/15.1.0/tuple:2487:38: note: use '-fdiagnostics-all-candidates' to display considered candidates
 2487 |       return std::__get_helper<__idx>(__t);
      |              ~~~~~~~~~~~~~~~~~~~~~~~~^~~~~
Compiler returned: 1
```

On clang 20.1.0 we have:
```
In file included from <source>:1:
/opt/compiler-explorer/gcc-14.2.0/lib/gcc/x86_64-linux-gnu/14.2.0/../../../../include/c++/14.2.0/tuple:2484:21: error: static assertion failed due to requirement '__idx < sizeof...(_Types)': the type T in std::get<T> must occur exactly once in the tuple
 2484 |       static_assert(__idx < sizeof...(_Types),
      |                     ^~~~~~~~~~~~~~~~~~~~~~~~~
<source>:5:19: note: in instantiation of function template specialization 'std::get<float, int, double>' requested here
    5 |     auto x = std::get<float>(t);
      |                   ^
/opt/compiler-explorer/gcc-14.2.0/lib/gcc/x86_64-linux-gnu/14.2.0/../../../../include/c++/14.2.0/tuple:2484:27: note: expression evaluates to '2 < 2'
 2484 |       static_assert(__idx < sizeof...(_Types),
      |                     ~~~~~~^~~~~~~~~~~~~~~~~~~
/opt/compiler-explorer/gcc-14.2.0/lib/gcc/x86_64-linux-gnu/14.2.0/../../../../include/c++/14.2.0/tuple:2486:14: error: call to deleted function '__get_helper'
 2486 |       return std::__get_helper<__idx>(__t);
      |              ^~~~~~~~~~~~~~~~~~~~~~~~
/opt/compiler-explorer/gcc-14.2.0/lib/gcc/x86_64-linux-gnu/14.2.0/../../../../include/c++/14.2.0/tuple:2438:5: note: candidate function [with __i = 2, _Types = <int, double>] has been explicitly deleted
 2438 |     __get_helper(const tuple<_Types...>&) = delete;
      |     ^
/opt/compiler-explorer/gcc-14.2.0/lib/gcc/x86_64-linux-gnu/14.2.0/../../../../include/c++/14.2.0/tuple:2427:5: note: candidate template ignored: could not match '_Tuple_impl' against 'tuple'
 2427 |     __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
      |     ^
/opt/compiler-explorer/gcc-14.2.0/lib/gcc/x86_64-linux-gnu/14.2.0/../../../../include/c++/14.2.0/tuple:2432:5: note: candidate template ignored: could not match '_Tuple_impl' against 'tuple'
 2432 |     __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
      |     ^
/opt/compiler-explorer/gcc-14.2.0/lib/gcc/x86_64-linux-gnu/14.2.0/../../../../include/c++/14.2.0/tuple:2486:14: error: non-const lvalue reference to type 'float' cannot bind to a temporary of type '__enable_if_t<(2UL >= sizeof...(_Types))>' (aka 'void')
 2486 |       return std::__get_helper<__idx>(__t);
      |              ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
3 errors generated.
Compiler returned: 1
```

(The output is copied verbatim from Compiler Explorer, using indicated compilers, with no extra compiler flags.)

There are several problems with this diagnostic that will make it hard for the users to understand where the source of the problem lies:

* the actual error doesn't properly say what is wrong
  * the code points to `__idx < sizeof...(_Types)`, but that has nothing familiar to the user
  * the error message says `the type T in std::get<T> must occur exactly once in the tuple`, but that is not very specific.
* the actual error source is inside of the standard library, not in the user code
  * in both cases, there is a note pointing to the user code, buried inside of multiple lines of library error/nodes
* we see secondary errors in the output
* the error message is too long, contains too much noise, making it harder to focus on the real issue

What we really want instead is something like:
```
<source>:5:19: error: there is no element of type `float` in tuple with types <int, double>
    5 |     auto x = std::get<float>(t);
      |                   ^
```

That is it; no extra line pointing inside the source code of standard library.

If, on the other hand, we slightly change the problem to the following code:
```
std::tuple<int, double, float, float> t;
auto x = std::get<float>(t);
```
, the exact call to `std::get<float>` should produce an error message like:
```
<source>:5:19: error: the element of type `float` in appears multiple times in tuple with types <int, double, float, float>
    5 |     auto x = std::get<float>(t);
      |                   ^
```

# Examples # {#examples}

TODO

# Design overview # {#design-overview}

TODO

# Design discussions # {#discussions}

TODO

# Implementation # {#implementation}

TODO

# Specification

TODO

<!--
References:
- https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2018/p1267r0.pdf
- https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2429r0.pdf
- https://discourse.llvm.org/t/rfc-improving-clang-s-diagnostics/62584/1

-->